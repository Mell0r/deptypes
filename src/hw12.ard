\import Data.List
\import Function (o)
\import Function.Meta
\import Logic
\import Paths
\import Paths.Meta
\import hw07 (In, contrProp)
\import lect12 \hiding (Int', pos, neg)

-- 1. Определите функцию negPred : Int -> Int такую, что negPred x = x, если x > 0, и negPred x = x - 1, если x <= 0

\func negPred (x : Int) : Int
  | pos (suc x) => pos (suc x)
  | neg x => neg (suc x)
  | 0 => neg 1

-- 2. Определите функции сложения и умножения для Int

\func \infixl 6 + (x y : Int) : Int
  | pos x, pos y => pos $ x Nat.+ y
  | pos x, neg y => x Nat.- y
  | neg x, pos y => y Nat.- x
  | neg x, neg y => neg $ x Nat.+ y

\func \infixl 7 * (x y : Int) : Int
  | pos x, pos y => pos $ x Nat.* y
  | pos x, neg y => neg $ x Nat.* y
  | neg (suc x), pos y => neg $ suc x Nat.* y
  | neg (suc x), neg (suc y) => pos $ suc x Nat.* suc y

-- 3. Определите тип данных BinNat для бинарных натуральных чисел
--    У него должно быть три конструктора: для 0, для чисел вида 2*n и чисел вида 2*n+1
--    Такой тип данных содержит несколько различных представлений для нуля
--    Используйте типы данных с условиями, чтобы вычислительно отождествить различные нули

\data BinNat
  | zero
  | even BinNat \with {
    | zero => zero
  }
  | odd BinNat \with {
    | zero => zero
  }

-- 4. Докажите, что функция pred сюръективна

\func pred (n : Nat) : Nat
  | 0 => 0
  | suc n => n

\func pred-is-sur : isSur pred =>
  \lam n => inP (suc n, idp)

-- 5. Докажите, что функция suc не сюръективна

\func suc-is-not-sur (p : isSur suc) : Empty =>
  \case p 0 \with {
    | inP (a, q) => \case q
  }

-- 6. Пусть f : A -> B и g : B -> C ─ некоторые функции
--    Докажите, что если f и g сюръективны, то g o f также сюръективна
--    Докажите, что если g o f сюръективна, то g также сюръективна

\func o-sur
  {A B C : \Type}
  (f : A -> B)
  (g : B -> C)
  (fSur : isSur f)
  (gSur : isSur g)
  : isSur (g o f) => \lam c => \case gSur c \with {
    | inP (b, p) => \case fSur b \with {
      | inP (a, q) => inP (a, pmap g q *> p)
    }
  }

\func o-sur'
  {A B C : \Type}
  (f : A -> B)
  (g : B -> C)
  (p : isSur (g o f))
  : isSur g => \lam c => \case p c \with {
    | inP (a, p) => inP (f a, p)
  }

-- 7. Определите множество конечных подмножеств множества A,
--    то есть списков элементов A с точностью до перестановок и повторений элементов

\truncated \data Set (A : \Set) : \Set
  | subset (List A)
  | equals
    {xs ys : List A}
    (\Pi (a : A) -> TruncP (In a xs) <-> TruncP (In a ys))
    : subset xs = subset ys

-- 8. Докажите теорему Кантора

-- Теорема Кантора говорит, что для любого множества A мощность множества его подмножеств строго больше, чем мощность A

-- Множество подмножеств можно определить следующим образом:

\func Subs (A : \Set) => A -> \Prop

-- Формально утверждение теоремы Кантора состоит из двух частей:
-- "существует инъекция из A в Subs A" и "не существует сюръекции из A в Subs A"

\func cantor1 (A : \Set) : \Sigma (f : A -> Subs A) (isInj f)
  => (=, =-isInj)

\func cantor2 (A : \Set) (f : A -> Subs A) (fSur : isSur f) : Empty
  =>
    \let B : Subs A => \lam a => Not (f a a)
    \in \case fSur B \with {
      | inP (y, p) => contrProp {B y}
          (\lam yInB _ => yInB $ rewrite p yInB)
          (\lam yNotInB fAA => yNotInB $ rewriteI p fAA)
    }

-- Optional
-- 9. Постройте функции Nat -> BinNat и BinNat -> Nat и докажите, что они взаимно обратны

\func NatToBinNat (n : Nat) : BinNat => {?}

\func BinNatToNat (b : BinNat) : Nat => {?}

\func nbn (n : Nat) : BinNatToNat (NatToBinNat n) = n => {?}

\func bnb (b : BinNat) : NatToBinNat (BinNatToNat b) = b => {?}
